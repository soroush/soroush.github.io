<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The Bored Octopus</title>
    <link>https://soroush.github.io/en/</link>
    <description>Recent content on The Bored Octopus</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 13 Aug 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://soroush.github.io/en/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>PIMPL idiom in C&#43;&#43;</title>
      <link>https://soroush.github.io/en/220/08/13/pimpl-idiom-in-cpp/</link>
      <pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://soroush.github.io/en/220/08/13/pimpl-idiom-in-cpp/</guid>
      <description>&lt;p&gt;Developers working on a &amp;ldquo;software library&amp;rdquo; in C++ (or any other
native language) should follow a set of critically important rules, or
their customers will soon be in trouble using their product. Some of
these rules are for example
&lt;strong&gt;&lt;a href=&#34;https://semver.org/&#34;&gt;Semantic Versioning&lt;/a&gt;&lt;/strong&gt;, &lt;strong&gt;Good API Design&lt;/strong&gt;
and &lt;strong&gt;Keeping Backward Compatibility&lt;/strong&gt;. The later one has many aspects
and requires its detailed post. In this post, I will discuss one of
the vastly used techniques in C++ which helps developers to keep
&lt;strong&gt;Backward Compatibility&lt;/strong&gt; in binary (ABI) level.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pure Functions in C&#43;&#43;‬</title>
      <link>https://soroush.github.io/en/2020/08/06/pure-functions-in-cpp/</link>
      <pubDate>Thu, 06 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://soroush.github.io/en/2020/08/06/pure-functions-in-cpp/</guid>
      <description>&lt;p&gt;One of the best optimisation features of C++ is declaring functions as &lt;strong&gt;pure&lt;/strong&gt;.
This one is less known to developers, though it can be an excellent optimisation
hit for your software. Marking a function with “pure” attribute enables a wide
range of possible optimisations for the compiler. You must declare your pure
functions as such, in all code that cares about performance. In this post, I am
going to show how to use this feature and its effects on generated code.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>English Blog!</title>
      <link>https://soroush.github.io/en/2020/08/05/translating-blog/</link>
      <pubDate>Wed, 05 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://soroush.github.io/en/2020/08/05/translating-blog/</guid>
      <description>So I started to translate my old Persian content into English, as an exercise (well, mostly out of bordem duo to COVID-19 lockdown&amp;hellip;). I&amp;rsquo;ll keep dates intact. I hope you&amp;rsquo;ll find it interesting&amp;hellip;</description>
    </item>
    
    <item>
      <title>Non-Gregorian Calendar Systems in Qt</title>
      <link>https://soroush.github.io/en/2020/08/02/persian-calendar-in-qt/</link>
      <pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://soroush.github.io/en/2020/08/02/persian-calendar-in-qt/</guid>
      <description>&lt;p&gt;For Iranian general public, working with date and time in a computer system has always
been challenging. As opposed to - almost - entire population of the planet, we use a
different calendar system (actually a better one!) but computer systems are not
designed and developed with non-Gregorian calendaring in mind. So we always have
to use unconventional methods and hacks to provide functionality of
the official calendar of the country - Solar Hijri&amp;hellip;&lt;/p&gt;
&lt;p&gt;Personally, for me the absence of the Solar Hijri calendar in Qt has always
been annoying. Whenever I wanted to work with date and time in my C++ GUI
applications, I had two options: Either use my own custom widgets (which where
not as good as Qt&amp;rsquo;s widgets), or simply use the Gregorian calendar (which is
annoying for the final user).&lt;/p&gt;
&lt;p&gt;Since version 4.6, right after I released Persian translation of Qt, I was
thinking of implementing the solar calendar for this
framework. Unfortunately, in that time it was not possible to implement it for
many reasons. However, I made some prototypes, but it did not make it to Qt5.
Qt5 had its own sad story, with the premature release of version 5.0; the
opportunity created by changing the major version was also missed.
Though finally, after 6 years and forgetting all about calendars, I had the
chance to implement the solar Hijri calendar for Qt 5.10. The final version has been
released with Qt 5.14 on December 12, 2019. This post describes challenges, and
the process of the work, and also the API itself.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://soroush.github.io/en/en/static/images/jalali.gif&#34;/&gt; &lt;figcaption&gt;
            &lt;h4&gt;Running Example&lt;/h4&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;</description>
    </item>
    
    <item>
      <title>Mathematical Constants in C&#43;&#43;</title>
      <link>https://soroush.github.io/en/2018/04/13/math-constants-in-cpp/</link>
      <pubDate>Fri, 13 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://soroush.github.io/en/2018/04/13/math-constants-in-cpp/</guid>
      <description>&lt;p&gt;None of C++ standards has defined π number. So every programmer who needs to do
some math including, for example, trigonomerty or statistics, has to define π
herself. Luckily header files have defined π (See &lt;code&gt;M_PI&lt;/code&gt; in &lt;code&gt;math.h&lt;/code&gt;). Though it
is not ultimately safe and portable to use these constants. It might casue
numeric errors in critical applications. In this blog post, I am going to show a
better way to reach a safe π.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Worst Ever Qt Bug (for me!)</title>
      <link>https://soroush.github.io/en/2017/05/09/worst-ever-bug/</link>
      <pubDate>Tue, 09 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://soroush.github.io/en/2017/05/09/worst-ever-bug/</guid>
      <description>&lt;p&gt;I think Qt is one of the best software development frameworks. It has a nice GUI
library alongside with many other tools, provided as a neat and clean API. KDE
desktop environment is almost entirely based on Qt framework. I&amp;rsquo;ve been using it
for a decade now, and I have successfully delivered dozens of projects &amp;ndash; both
embedded and desktop &amp;ndash; most of them only using Qt. Though starting from version
5.3, a tiny bug has appeared in the core library, that makes life difficult for
me: It is impossible to insert invisible characters in Qt&amp;rsquo;s text engine. That is
you can&amp;rsquo;t type ZWNJ, ZWJ, LRE, RLE and PDF characters. (I have described what
they in this post:
&lt;a href=&#34;&#34;&gt;Control Charachters and Bi-Directional Text&lt;/a&gt;.
The effect of this bug is so huge that makes it impossible for me to use KDE or
any other application that uses Qt. To see how it didn&amp;rsquo;t work for us, imagine
being unable to type, for example, &amp;ldquo;space&amp;rdquo; character in any application on your
operating system! In this post I am going to show a workaround and explain how
to fix this bug. It is already fixed in recent versions of Qt, though it is not
in official repositories yet. Fortunately, the workaround is very simple and
does not break anything. Finally I&amp;rsquo;ll provide a patch for 5.9. Hope this helps
someone.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
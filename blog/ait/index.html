
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>پروژهٔ AIT - اختاپوس خسته</title>
  <meta name="author" content="سروش">

  
  <meta name="description" content="پروژهٔ AIT بزرگ‌ترین کار متن‌بازی هست که پیاده‌سازی کردم. AIT مخفف
Artificial Intelligence Toolkit
هست. هدف این کتابخانه فراهم کردن یک پلتفرم توسعه &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://soroush.github.io/blog/ait">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="اختاپوس خسته" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="https://fonts.googleapis.com/css?family=Inconsolata|PT+Serif|PT+Serif+Caption" rel="stylesheet">
<!--- MathJax Configuration -->
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-44259177-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">اختاپوس خسته</a></h1>
  
    <h2>یادداشت‌هایی پیرامون کد، زندگی و دوستان</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
  
  
  
  
<ul class="subscription">
  <li><a href="https://github.com/soroush" rel="subscribe-github" title="@soroush در گیت‌هاب">گیت‌هاب</a></li>
</ul>
  
  
  
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:soroush.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="جستجو"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">بلاگ</a></li>
  <li><a href="/blog/archives">بایگانی</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      
        <h1 class="entry-title">پروژهٔ AIT</h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2013-11-26T00:00:00+03:30" pubdate data-updated="true">۵ 
      آذر 
      ۱۳۹۲</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>پروژهٔ AIT بزرگ‌ترین کار متن‌بازی هست که پیاده‌سازی کردم. AIT مخفف
Artificial Intelligence Toolkit
هست. هدف این کتابخانه فراهم کردن یک پلتفرم توسعه برای پروژه‌های تحقیقاتی و صنعتی
در زمینهٔ هوش مصنوعی هست. حقیقتش اهداف بزرگ‌تری هم داره. مثلاً پر کردن خلأ بین
آکادمی و صنعت در زمینهٔ هوش مصنوعی یکی از کارهایی هست که مدت‌هاست آرزو دارم انجامش بدم. توی پست دیگه
در مورد این خلأ صحبت خواهم کرد.</p>

<p>این پست به بررسی کتابخانهٔ AIT و کاربردهای فوق‌العاده جالبی که می‌تونه داشته
باشه خواهد پرداخت. صفحهٔ اصلی پروژه رو توی
<a href="http://soroush.github.io/ait/">همین سایت گذاشتم</a>
و
<a href="https://github.com/soroush/ait">رپوزیتوری گیت</a>
هم در گیت‌هاب در دسترس هست.</p>

<!-- more -->


<h2>صورت مسأله</h2>

<p>و آمّا AIT&hellip; این پروژه اول به صورت یک تکلیف درسی در دانشگاه نوشته شد و بعداً
تکمیل‌ترش کردم و به‌صورت متن‌باز (با اجازه‌نامهٔ LGPL 2.1) منتشر کردم. در حال
حاضر نسخهٔ 0.1.0 هست و طبیعتاً نمی‌تونه توی پروژه‌های دیگه استفاده بشه. تا آخر
امسال اولین نسخهٔ پایدارش رو منتشر خواهم کرد. همون‌طور که گفتم، AIT یک پلتفرم
توسعه برای پروژه‌های تحقیقاتی و صنعتی هست.</p>

<p>ترم بهار ۹۱-۹۲ توی دانشگاه واحد درسی سیستم‌های همروند رو گذروندم. منتهی موضوع
درس ارائه شده، اصلاً سیستم‌های همروند نبود بلکه «مسائل ارضای محدودیت» بود. چون
ثبت درس اختیاری جدید سخته، با یه اسم دیگه ارائه داده بودن.</p>

<p>پروژهٔ این درس پیاده‌سازی الگوریتم
<a href="">Asynchronous Backtracking</a>
و مشتقاتش بود. این
الگوریتم توسط Yokoo و همکارانش سال 1992 برای حل مسائل
ارضای محدودیت توزیع‌شده
(<a href="http://en.wikipedia.org/wiki/Distributed_constraint_optimization">Distributed constraint optimization</a>)
ارائه شده. بهینه‌سازی‌های متعددی هم تا
به‌حال براش نوشتن. وظیفهٔ ما برای پروژهٔ پایانی درس، این بود که الگوریتم‌های
ABT، Agile ABT و FC رو برای
حل مسألهٔ هشت‌وزیر پیاده‌سازی کنیم.</p>

<p>بزرگ‌ترین مشکل این پیاده‌سازی اینه که ماهیت مسأله توزیع شده است. مثلاً برای حل
مسأله‌ای که \(n\) تا متغیر رو می‌خواد مقداردهی کنه، باید به همون تعداد عامل
(agent)
اجرا بشه و تمام این عامل‌ها با همدیگه ارسال و دریافت داده خواهند داشت.</p>

<h2>مشکلات</h2>

<p>اولین و بزرگ‌ترین مشکلی که برام به‌وجود اومد، برقراری ارتباط بین ایجنت‌ها بود.
باید طوری بین ایجنت‌ها ارتباط برقرار می‌کردم که شرایط زیر ارضا می‌شد:</p>

<ul>
<li>هر ایجنت قابلیت ارسال و دریافت داده به‌صورت ناهمگام از تمام ایجنت‌ها داشته
باشه</li>
<li>ارتباطات قابل اعتماد باشه</li>
<li>ترتیب حضور ایجنت‌ها (حتا مانیتور!) مهم نباشه</li>
</ul>


<p>ایجنت مانیتور به ایجنتی گفته میشه که مسئول مقداردهی به هیچ متغیری نیست و صرفاً
پایان مسأله رو تشخیص میده و بقیهٔ ایجنت‌ها رو خاموش می‌کنه.</p>

<p>مشکل دیگه‌ای که پیدا کرده بودم نحوهٔ پکت‌بندی و ارسال و دریافت داده‌ها بین
برنامه‌ها بود. معمولاً وقتی همچین سناریوای پیش میاد یه برنامه‌نویس گزینه‌های
متعددی رو در اختیار داره که ازشون استفاده کنه. اگر خیلی ول‌انگار باشه و یا جزو
برنامه‌نویس‌های نسل جدید (نفخ‌افزارنویس‌ها) باشه از ابزارهایی مثل WCF، XML، SOAP
و یا حتا RPC برای انتقال داده استفاده می‌کنه. حتا مورد داشتیم برای ارسال و
دریافت اطلاعات توی شبکه بین دو برنامه اصرار داشته که HTTP Request بفرستیم و
بگیریم! (استاد درس مهندسی نرم‌افزار ۲). حتا اگر برنامه‌نویس خیلی خیلی راحت‌طلب باشه (مثل
توسعه‌دهنده‌های <a href="http://www.tsetmc.com/">شرکت فناوری اطلاعات بورس تهران</a>) از
مزخرفاتی مثل WSDL و JSON هم می‌تونه استفاده کنه.</p>

<p>اما متأسفانه {از دید خودم} و خوشبختانه {از دید برنامه‌ها} من به سبک
برنامه‌نویس‌های دههٔ هفتاد و با دید کاربردگرا و مقیاس‌گرا به قضیه نگاه می‌کنم.
یعنی تک‌تک بایت‌ها و ثانیه‌های مصرف شده در برنامه برای من مهم هستن. استراتژی‌های اصلی توسعهٔ
نرم‌افزار رو همیشه با همین دید انتخاب می‌کنم. و البته معمولاً تو دردسر می‌افتم. در همین راستا تصمیم گرفتم با یک پروتکل
فوق‌سبک و دست‌ساز داده‌ها رو بفرستم. خوب مسلماً اولین و ساده‌ترین چیزی که به ذهن
می‌رسه
<a href="http://en.wikipedia.org/wiki/Serialization">Serialization</a>
هست.</p>

<p>اما کار به این‌جا ختم نمی‌شه! سریال‌کردن دیتا با پروتکل‌های سبک
<a href="http://en.wikipedia.org/wiki/Request_for_Comments">RFC</a>
مشکلات
پیاده‌سازی داره. مهم‌ترین این مشکلات برقراری ویژگی‌های چند سکویی هست. قبلاً گفتم
که یکی از معیارهای اصلی من برای توسعهٔ نرم‌افزار، نوشتن کد قابل حمل هست. یعنی
برنامه‌ای که می‌نویسم باید روی تمام معماری‌ها (
<a href="http://en.wikipedia.org/wiki/ARM_architecture">ARM</a> , <a href="http://en.wikipedia.org/wiki/X86">x86</a> , <a href="http://en.wikipedia.org/wiki/X86-64">x86_64</a>
) و تمام
سیستم‌عامل‌ها، مثل لینوکس، یونیکس، FreeBSD, OS2 و حتا ویندوز؛ قابل اجرا باشه.
برآورده کردن این هدف کار ساده‌ای نیست و اساس اکوسیستم (بسیار پردسر) توسعهٔ نرم‌افزار من رو
تشکیل میده. از بحث اصلی خارج نشیم! سریال کردن داده‌ها به سبک پروتکل‌های RFC با
حفظ قابلیت حمل کار ساده‌ای نیست. چطور؟ شما موانع زیادی برای برقراری ویژگی قابلیت
حمل دارید از جمله:
<a href="http://en.wikipedia.org/wiki/Endianness">bitness یا همون endianness</a>
و
<a href="http://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>
. اولی مربوط به معماری میشه. دومی هم همین‌طور :)
bitness
یک معماری ترتیب بیت‌ها رو مشخص می‌کنه. کلاً دو نوع bitness داریم. سیستم یا
<a href="http://en.wikipedia.org/wiki/Little_endian#Little-endian">Little Endian</a>
 هست یا
<a href="http://en.wikipedia.org/wiki/Little_endian#Big-endian">Big Endian</a>
. از بین سیستم‌هایی که می‌شناسیم و باهاشون سروکار
داریم، ARM از نوع BE هست و بقیه از نوع LE.</p>

<p><img class="left" src="/images/posts/Big-Endian.png" title="نمایش Big Endian" >
فرض کنید شما یک عدد صحیح رو می‌خواهید بین  دو تا پروسس منتقل کنید. یکی از این
پروسس‌ها روی سیستم‌عامل اندرویید گوشی‌تون اجرا میشه و دیگری روی لینوکس
کامپیوترتون. اگر اولی یک عدد صحیح (int) رو به شکل 0A0B0C0D در چهار بایت ذخیره
کرده باشه، دومی همون عدد رو به شکل 0D0C0B0A ذخیره می‌کنه! اصلاً کلمهٔ
Little Endian
هم از همین‌جا منشأ گرفته. یعنی بایت کم‌اهمیت، قبل از بایت پراهمیت ذخیره میشه.</p>

<p>نیازی به توضیح بیشتر نیست که اگر یک داده رو از سیستم اولی به سیستم دومی بفرستیم
(به هر طریقی) شاهد یک فاجعه خواهیم بود. مگر این که مکانیزم فراوری داده رو تو
پایین‌ترین سطح مدیریت کنیم! طبیعتاً توسعه‌دهنده‌های حرفه‌ای قبل از ما راهکار
مناسب رو ارائه دادن. با یک جستجوی ساده توی اینترنت و خوندن چند تا راهنما و
مقایسه به این نتیجه می‌رسیم که ابزارهایی مثل
<a href="http://www.boost.org/doc/libs/1_55_0/libs/serialization/doc/index.html">Boost Serialization Library</a>
و چند
تای دیگه حذف میشن. در آخر می‌مونه کتابخانهٔ بسیار عالی و پرمحتوای
<a href="https://developers.google.com/protocol-buffers/">Google Protocols Buffers</a> .
بافرهای پروتکل کتابخونه‌ای هست که به گفتهٔ خود نویسندگانش در گوگل به‌شکل درون‌سازمانی استفاده میشه و همون‌طور که از اسمش پیداست برای پیاده‌سازی پروتکل‌ها (احتمالاً RFC ها و غیره) ازش استفاده می‌کنن. تمام مسائل و مشکلات مربوط به معماری، اعم از bitness، تفاوت PDTها در زبان‌ها و همچنین نمایش‌های باینری متفاوت در پلتفرم‌های مختلف، در نظر گرفته شده و حل شده :)</p>

<h3>وقتی برنامه‌ها با هم حرف می‌زنند</h3>

<p>با استفاده از PB مشکلات مربوط به ساخت پکت‌های باینری حل میشه. اما چطوری این پکت‌ها رو بین برنامه‌ها رد و بدل می‌کنیم؟ خوب جواب اول استفاده از مکانیزم‌های معروف IPC (همون ارتباط میان‌پردازه‌ای) مثل Shared Memory و یا pipe هست. اما من ترجیح میدم از سوکت‌ها استفاده کنم. چون میشه بعداً گسترده‌ترش کرد و روی چند تا کامپیوتر اجراش کرد. با این حال API های استاندارد سوکت‌ها خیلی سطح پایین هستند و کار کردن باهاشون برای کسی که نمی‌خواد وارد دردسرهای سناریوهای مختلف ارتباطی بشه، کار چندان جالبی نیست. منظورم از سناریو، حالت‌های متداولی هست که ممکنه پیش بیاد. بذارید چند تا مثال بزنم:</p>

<ul>
<li>داده ارسال نشد؟ دوباره سعی کن.</li>
<li>گیرنده گوش نمیده؟ صبر کن اجرا بشه دوباره بفرست.</li>
<li>داده‌ای که اومده قسمتی از یه دادهٔ بزرگ‌تره؟ قسمتی از آخر یه پکت و اول یه پکت دیگه‌ست؟ خوب داده‌ها رو جمع کن، پکت‌ها رو تحلیل کن، بچسبون به هم و سالم به من تحویل بده.</li>
</ul>


<p>خوب این‌جا هم یه پیاده‌سازی خیلی عالی وجود داره به اسم ∅MQ یا همون
<a href="http://www.zeromq.org/">ZeroMQ</a>
.  این کتابخانه در واقع پیاده‌سازی یک لایهٔ میانی بین
<a href="http://en.wikipedia.org/wiki/Transport_Layer">Transport Layer</a>
و
<a href="http://en.wikipedia.org/wiki/Application_Layer">Application Layer</a>
در مدل شبکه هست. از این ابزار به عنوان
Intelligent Transport Layer
هم یاد می‌کنند.</p>

<p>گزینهٔ دیگه‌ای هم برای برقراری ارتباط وجود داشت و اون هم استفاده از
<a href="http://www.open-mpi.org/">OpenMPI</a>
بود که کار ∅MQ و Protocol Buffers رو یک‌جا انجام میده. اما از ازش استفاده نکردم تنها به یک دلیل: در آینده می‌خوام این برنامه روی اینترنت و شبکه‌های پیچیده تست بشه. بنابراین باید ویژگی
<a href="http://en.wikipedia.org/wiki/NAT_traversal">NAT Traversal</a>
رو براش پیاده‌سازی کنم که با استفاده از API ی
OpenMPI
قابل پیاده‌سازی نیست.</p>
</div>


  <footer>
    <p class="meta">
      
  



  <span class="byline author vcard">نوشته شده توسط <span class="fn">
  
    سروش
  
  </span></span>


      








  


<time datetime="2013-11-26T00:00:00+03:30" pubdate data-updated="true">۵ 
      آذر 
      ۱۳۹۲</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://soroush.github.io/blog/ait/" data-via="gigtupus" data-counturl="http://soroush.github.io/blog/ait/" >توئیت</a>
  
  
  <div class="g-plusone" data-size="small"></div>
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment right" href="/blog/bitcoin-fa/" title="پست قبلی: بیت‌کوین فارسی">&laquo; بیت‌کوین فارسی</a>
      
      
        <a class="basic-alignment left" href="/blog/confusing/" title="پست بعدی: سردرگمی">سردرگمی &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>دیدگاه‌ها</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>


</div>

<aside class="sidebar">
  
    
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  حق تألیف &copy; 2017 - سروش -
  <span class="credit">قدرت‌گرفته از <a href="http://octopress.org">اکتوپرس</a> | براساس طرح <a href="https://github.com/lucaslew/whitespace">فضای سفید</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'soroushr';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://soroush.github.io/blog/ait/';
        var disqus_url = 'http://soroush.github.io/blog/ait/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>








  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>

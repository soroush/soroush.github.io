<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fa-ir" lang="fa-ir">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.57.2" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>رابط برنامه‌نویسی &middot; اختاپوس خسته</title>

  
  <link type="text/css" rel="stylesheet" href="https://soroush.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://soroush.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://soroush.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://soroush.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_SVG">
</script> 
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    "HTML-CSS": {
    styles: {
        ".MathJax .mo, .MathJax .mi": {color: "black ! important"}
    }
    }
});
</script> 




</head>

  <body class=" layout-reverse">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://soroush.github.io/"><h1>اختاپوس خسته</h1></a>
      <p class="lead">
       یادداشت‌هایی دربارهٔ برنامه‌نویسی و زندگی 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://soroush.github.io/">صفحهٔ اول</a> </li>
        
      </ul>
    </nav>

    <p>حقوق نشر محفوظ است.</p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>رابط برنامه‌نویسی</h1>

  <time datetime=2019-08-27T00:00:00Z class="post-date">سه‌شنبه، ۵ شهریور ۱۳۹۸</time>
  <figure>
    <img src="/static/images/api.jpg"/> 
</figure>


<p>یکی از مباحث مهم در زمینهٔ مهندسی نرم‌افزار و به‌ویژه برنامه‌نویسی؛ مفهوم «رابط
برنامه‌نویسی» یا
API
است. فهمیدن و استفاده کردن از این مبحث در برنامه‌نویسی اهمیت زیادی داره و رعایت
نکردن اصول توسعه نرم‌افزار از دید طراحی رابط‌ها می‌تونه به شدت مشکل‌ساز باشه یا
حتی در حالت‌هایی باعث شکست پروژه‌های نرم‌افزاری هم بشه. در واقع میشه گفت دلیل
اصلی موفقیت بسیاری از کتابخانه‌های سی و سی‌پلاس‌پلاس در طراحی API مناسب و
همچنین رعایت سازگاری API خلاصه میشه.</p>

<p>در این پست در مورد مفهوم، استفاده و طراحی API می‌نویسم. این پست قسمتِ اول از
سه‌گانه‌ای در مورد مدیریت انتشار خواهد بود. روش‌های مدیریت نسخه؛ مدیریت
پیش‌نیازی و انتشار مجموعه مباحث این سه قسمت رو تشکیل میدن.</p>

<h2 id="تعریف">تعریف</h2>

<p>رابط برنامه‌نویسی نرم‌افزار کاربردی (یا به صورت خلاصه رابط برنامه‌نویسی)، رابط
بین یک کتابخانه یا سیستم‌عامل و برنامه‌هایی هست که قراره ازش سرویس بگیرن.</p>

<p>رابط‌ها کارکردهایی را تعریف می‌کنند که کتابخانه یا سیستم‌عامل می‌تونه ارائه
بده. رابط یک مفهوم مجرد هست. یعنی جزئیات نداره. مثلا تعریف نمی‌کنه که زبان
برنامه‌نویسی یا مکانیزم ارتباطی چی باید باشه.
به عبارت ساده‌تر، رابط برنامه‌نویسی <strong>مجموعه‌ای از توابع</strong> است که یک برنامه
قراره از برنامهٔ دیگه <strong>صدا بزنه</strong>. حالا این برنامه می‌تونه یک سرویس روی وب، یک
برنامهٔ معمولی یونیکس یا یک برنامهٔ گرافیکی ویندوز باشه. و صدا زدن هم می‌تونه
فراخوانی وب‌سرویس روی
SOAP
یا
REST
باشه یا پاس دادن یه سری پارامتر از خط فرمان یا به‌طور مستقیم اضافه کردن و
استفاده کردن از کتابخانهٔ از پیش کامپایل شده.</p>

<p>در اینجا بیشتر به بررسی رابط‌های سی‌پلاس‌پلاس خواهم پرداخت. بنابراین تعریف من
از رابط؛ در واقع میشه روشی که یک کتابخانهٔ
‪C++‬
استفاده میشه. این کتابخانه می‌تونه فقط شامل فایل‌های سرآیند باشه یا شامل یک کد
از قبل کامپایل شده.</p>

<h3 id="api-عمومی">API عمومی</h3>

<p>رابط عمومی یا
Public API
قسمتی از رابط هست که شما به‌طور عمومی در اختیار بقیهٔ توسعه‌دهنده‌ها قرار میدید
که از نرم‌افزار یا کتابخانهٔ شما استفاده کنند. به‌طور کلی برای کتابخانه‌های
‪C++‬
این رابط شامل فایل‌های سرآیند (فایل‌های هدر) هست که موقع نصب کتابخانه به همراه
باینری‌ها نصب میشن. در واقع میشه گفت تنها قسمت غیرباینری که منتشر میشه رابط
برنامه‌نویسی هست.</p>

<h3 id="api-خصوصی">API خصوصی</h3>

<p>معمولاً کتابخانه‌ها رابط خصوصی ندارند. گاهی اوقات پیش میاد که تعداد فایل سرآیند
توی ساختار پروژه ایجاد میشه که توابع پراستفاده رو توی اون‌ها قرار میدیم؛ از
طرفی این توابع قرار نیست بخشی از کارکرد کتابخانهٔ اصلی باشند. این هدرها
بخشی از API عمومی نیستند و در هر نسخه ممکنه به‌طور کامل محتوای اون‌ها
حذف یا عوض بشه.</p>

<h3 id="اصول-ابتدایی-طراحی-رابط-برنامه-نویسی">اصول ابتدایی طراحی رابط برنامه‌نویسی</h3>

<p>برخلاف تصور؛ اصول طراحی رابط برنامه‌نویسی برای کتابخانه‌ها اهمیت بسیار زیادی
داره. در قسمت مربوط به مدیریت نسخه توضیح خواهم داد که به‌راحتی نمیشه رابط
برنامه‌نویسی رو عوض کرد. وقتی این کار رو انجام بدیم به احتمال خیلی زیاد کاربران
زیادی رو از دست خواهیم داد.</p>

<p>یک رابط برنامه‌نویسی باید دارای این ویژگی‌ها باشه:</p>

<ul>
<li>استفاده و به‌یادسپاری آن آسان باشد:</li>
<li>استفاده نادرست از آن محتمل نباشد؛</li>
<li>قابل گسترش باشد؛</li>
<li>جامع باشد؛</li>
<li>ثبات رویه (سازگاری درونی) داشته باشد.</li>
</ul>

<p>مهم‌ترین نکته در طراحی یک رابط برنامه‌نویسی خوب؛ <em>سادگی</em> هست. یک رابط خوب باید
به ساده‌ترین شکل ممکن پیاده‌سازی شده باشه و مرموز و پیچیده نباشه. یک مثال خیلی
ساده استفاده از سیستم تایپ در
‪C++‬
می‌تونه باشه. تابع زیر رو درنظر بگیرید:
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">print_rectangle</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div>
از اسم تابع مشخص هست که یک مستطیل رو چاپ می‌کنه. ولی مشخص نیست ورودی‌ها
مشخص‌کنندهٔ چه چیزی هستند. موارد زیر ممکن هست:</p>

<ul>
<li>مختصات نقطهٔ اول و طول و عرض مستطیل؛</li>
<li>مختصات نقطهٔ اول و مختصات نقطهٔ دوم.</li>
</ul>

<p>یا اگر توسعه‌دهنده خیلی آدم عجیبی باشه می‌تونه اینطوری هم باشه:</p>

<ul>
<li>مختص x نقطهٔ اول؛ مختص x نقطهٔ دوم؛ مختص y نقطهٔ اول؛ مختص y نقطهٔ دوم؛</li>
<li>&hellip;</li>
</ul>

<p>نسخهٔ بهتر این تابع در
‪C++‬
 می‌تونه چندین سربارگزاری از تابع اصلی با اشکال مختلف باشه. مثلاً همچین چیزی:
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">print_rectangle</span><span class="p">(</span><span class="k">const</span> <span class="n">point</span><span class="o">&amp;</span> <span class="n">top_left</span><span class="p">,</span> <span class="k">const</span> <span class="n">point</span><span class="o">&amp;</span> <span class="n">bottom_right</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">print_rectangle</span><span class="p">(</span><span class="k">const</span> <span class="n">point</span><span class="o">&amp;</span> <span class="n">top_left</span><span class="p">,</span> <span class="k">const</span> <span class="n">size</span><span class="o">&amp;</span> <span class="n">dimension</span><span class="p">);</span>
</code></pre></div></p>

<p>استفاده از رابط بالا ساده‌تر هست. علاوه‌بر سادگی با استفاده از رابط دوم؛ دوم
ویژگی رابط‌های خوب رو هم برآورده کردیم: یعنی عدم امکان استفاده نادرست. با
استفاده از این رابط جدید؛ احتمال این که کاربر به اشتباه از کتابخانهٔ ما استفاده
بکنه خیلی کمتره.</p>

<p>دومین ویژگی خیلی مهم رابط‌های برنامه‌نویسی خوب <em>سازگاری</em> هست. رابط
برنامه‌نویسی باید یک رویهٔ یکسان و قابل فهم در تمام API داشته باشه. به‌عنوان
مثال کیوت رو درنظر بگیرید. تمام کلاس‌های رابط عمومی با حرف Q شروع میشه و این
قاعده هیچ استثنایی نداره. یا کدهای خطا در کتابخانهٔ استاندارد C
همیشه وقتی کار تابع با موفقیت انجام شده باشه ۰ برمیگردونه و در غیر این صورت عدد
خطا برمیگرده.</p>

<h3 id="اصول-پیشرفته-طراحی-api">اصول پیشرفتهٔ طراحی API</h3>

<p>با همهٔ این‌ها؛ طراحی یک API خوب با استفاده از ‪C++‬ کار بسیار دشواری
هست. همونطور که توی مقدمه گفتم؛ دلیل شکست خیلی از پروژه‌های سی‌پلاس‌پلاس
فراهم نکردن رابط‌های خوب و یا رعایت نکردن سازگاری بوده. علاوه‌بر قوانین
کلاسیک طراحی رابط‌های خوب؛ یک سری قواعد دیگه مختص ‪C++‬ وجود داره که بیشتر
به‌شکل تجربی به دست میاد.</p>

<p><em>نکتهٔ مهم</em>: بعضی از این اصول استنتاجی و قطعی هستند و بعضی دیگه سلیقه‌ای و
کیفی.  این که کدوم رو بپذیرید کاملاً به شما بستگی داره. من در ادامه
صرفاً مواردی رو که به نظرم مهم هست لیست کردم.</p>

<h4 id="رابط-های-پیش-نیازها-را-تا-حد-ممکن-مخفی-کنید">رابط‌های پیش‌نیازها را تا حد ممکن مخفی کنید</h4>

<p>توضیح این توصیه مقداری سخت هست. ایدهٔ کلی اینه که وقتی از یم پیش‌نیاز (مثلاً یک
کتابخانهٔ دیگه) استفاده می‌کنیم؛ تا جایی که امکان داره نباید از انواع و توابع
اون پیش‌نیاز در رابط عمومی استفاده کنیم. دلیلش اینه که در صورت مرتکب شدن این
اشتباه؛ ما عملاً داریم دو تا رابط برای کد مشتری ارائه میدیم. به‌عنوان مثال فرض
کنید یک کتابخانهٔ پردازش گفتار فارسی می‌نویسیم که اتفاقاً از کتابخانهٔ پردازش
سیگنال
<a href="https://aquila-dsp.org/">Aquila</a>
استفاده کرده. برای تبدیل یک قطعه صورت فارسی به متن از این هدر استفاده می‌کنیم:</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#ifndef MY_AWSOME_HEADER
</span><span class="cp">#define MY_AWSOME_HEADER
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;aquila/global.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="c1">// ...
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">speach_to_text</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">uint8_t</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">);</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="cp">#endif
</span></code></pre></div>

<p>این فایل هدر چند تا ایراد اساسی داره. مهم‌ترینش اینه که تمام هدرهای کتابخانهٔ
Aquilla
رو اضافه کرده. با اضافه کردن این هدر؛ کد کاربر <code>aquila/global.h</code> رو هم
اضافه می‌کنه و هر چیزی که درون اون باشه به‌صورت بازگشتی و تا انتها اضافه
میشه. فضای کد کاربر پر از کلاس‌ها و ساختارهایی پردازش سیگنال میشه که
هیچ احتیاجی به اون‌ها نداره و ممکنه حتی باعث اختلاط در فضای نام‌گذاری هم
بشه.</p>

<p>راه حل خیلی ساده اینه که عبارت ‪<code>#include &lt;aquila/global.h&gt;</code>‬ به داخل
فایل cpp منتقل بشه. در حالت کلی همیشه باید تمام ‪<code>#include</code>‬ها رو تا حد
امکان از فایل‌های سرآیند (h یا hpp) به فایل‌های cpp منتقل کرد.</p>

<h4 id="پیش-نیازی-در-api-عمومی-یک-رابطه-متعدی-نیست">پیش‌نیازی در API عمومی یک رابطهٔ متعدی نیست</h4>

<p>رابطهٔ متعدی رو از ریاضات دبیرستان به خاطر دارید؟ رابطهٔ متعدی به رابطه‌ای گفته
میشه که این ویژگی رو داشته باشه:</p>

<p><em>اگر A با B و B با C رابطه داشته باشد؛ آنگاه A حتماً با C رابطه دارد.</em></p>

<p>این اصل میگه <strong>پیش‌نیازی</strong> یک رابطهٔ متعدی نیست. به‌ویژه در رابطه با API عمومی.
یعنی اگر یکی از پیش‌نیازهای اضافه شده به
API
عمومی کتابخانهٔ شما (مثلاً B) یک پیش‌نیاز دیگه (مثلا C) اضافه کرده باشه؛ API
عمومی کتابخانهٔ شما مبری از اضافه کردن اون پیش‌نیازی غیرمستقیم (یعنی C) نیست.</p>

<p>در این مورد یک مثال یکی به درک بهتر موضوع کمک می‌کنه. همین فایل هدر بالایی رو
درنظر بگیرید. قبلاً گفتم که مشکلات زیادی داره. یکی از این مشکلات همین عدم تعریف
پیش‌نیازی هست. فرض کنید برخلاف حالت قبلی نمی‌تونیم هدر
<code>aquila/global.h</code>
رو حذف کنیم. اگر به کد دقت کنید خواهید دید که علی‌رغم استفاده از
<code>std::string</code>، <code>std::vector</code> و <code>uint8_t</code>
هدرهای مربوطه اضافه نشدن و فقط هدر
<code>aquila/global.h</code>
اضافه شده. خوب کد به خوبی کامپایل میشه و کار می‌کنه چون قاعدتاً
<code>aquila/global.h</code>
تمام هدرهای مربوطه رو در خودش include کرده.  ولی API ناسالم هست. در واقع
APIای که ما داریم معرفی می‌کنیم؛ نباید به پیش‌نیازهای غیرمستقیم اتکا کنه. دلیلش
واضحه: ممکنه توی نسخه‌های بعدی کتابخانهٔ aquila ترتیب و تعداد هدرها عوض بشن.
ممکنه تو سیستم‌عامل‌های مختلف به‌صورت شرطی include شده باشند و غیره. در این
صورت کتابخانهٔ ما دیگه کامپایل نمیشه. این اصل به ما میگه که باید همچین APIای
داشته باشیم:</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#ifndef MY_AWSOME_HEADER
</span><span class="cp">#define MY_AWSOME_HEADER
</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;aquila/global.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="c1">// ...
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">speach_to_text</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">uint8_t</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">);</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="cp">#endif
</span></code></pre></div>

<h4 id="موارد-ریز-و-درشت">موارد ریز و درشت</h4>

<p>خیلی موارد دیگه در مورد طراحی API خوب در ‪C++‬ هست که خیلی از این‌ها
بدیهی به نظر می‌رسند. مثل:</p>

<ul>
<li>همیشه از namespace برای معرفی API جدید استفاده کنید؛</li>
<li>هرگز در API عمومی از <code>using namespace</code> استفاده نکنید؛</li>
<li>هرگز Rule of Three یا Rule of Five را نادیده نگیرید؛</li>
<li>توابع move constructor و اپراتور move assignment را همیشه <code>noexcept</code>
تعریف کنید؛</li>
<li>اگر تابع سازنده فقط یک آرگومان دارد؛ حتماً آن را <code>explicit</code> کنید؛</li>
<li>همیشه توابع و اعضای فقط-خواندنی را <code>const</code> کنید؛</li>
<li>هرگز در API عمومی از ‪<code>#define</code>‬ استفاده نکنید؛</li>
<li>همیشه نسخهٔ API را داخل خود API در دسترس قرار دهید؛</li>
<li>سازگاری ABI را حفظ کنید؛</li>
<li>و &hellip;</li>
</ul>

<h2 id="منابع-بیشتر">منابع بیشتر</h2>

<p>یکی از بهترین راه‌های یادگیری هر مبحث مربوط به برنامه‌نویسی به نظر من
خوندن کتاب هست. اگر با
C++
سر و کار دارید و پیشنهاد می‌کنم حتماً کتاب
<a href="https://books.google.co.uk/books/about/API_Design_for_C++.html">‪API Design for C++‬</a>
نوشتهٔ
Martin Reddy
را مطالعه کنید. این کتاب به شکل بسیار زیبا مفاهیم پیاده‌سازی و اهمیت
API خوب رو معرفی کرده. پر از مثال‌های مختلف از پروژهٔ Qt و بقیهٔ پروژه‌های
مطرح ‪C++‬ هست. قطعاً خوندنش خالی از لطف نیست.</p>
</div>

<h2>دیدگاه‌ها</h2>
<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "soroushr" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </main>

    
  </body>
</html>

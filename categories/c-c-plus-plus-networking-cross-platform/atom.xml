<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[طبقه‌بندی‌هاc,c++,networking,cross-platform | اختاپوس خسته]]></title>
  <link href="https://soroush.github.io/categories/c-c-plus-plus-networking-cross-platform/atom.xml" rel="self"/>
  <link href="https://soroush.github.io/"/>
  <updated>2017-09-16T00:30:22+04:30</updated>
  <id>https://soroush.github.io/</id>
  <author>
    <name><![CDATA[سروش]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[برنامه‌نویسی شبکه در ویندوز/لینوکس: libcpnet]]></title>
    <link href="https://soroush.github.io/blog/libcpnet/"/>
    <updated>2017-09-11T00:00:00+04:30</updated>
    <id>https://soroush.github.io/blog/libcpnet</id>
    <content type="html"><![CDATA[<p>کارفرمای کاری که الان دارم انجام میدم اصرار داره که برنامه‌ش علاوه‌بر لینوکس روی
ویندوز هم به‌خوبی اجرا بشه. مدیر من کاملاً این محدودیت رو پذیرفته و به کارفرما
گفته که با سخت‌افزاری که مشخصاتش رو اعلام می‌کنیم و با مشخصات کارکردی که اعلام
می‌کنیم، روی ویندوز هم می‌تونید برنامه رو اجرا کنید. خوب این تصمیم مشکلات بسیار
بزرگی برای برنامه‌نویس به‌وجود میاره. ازجمله برنامه‌نویسی شبکه&hellip; این پست به
بررسی این مشکلات و ارائهٔ یک راه حل خوب خواهد پرداخت (: اگر قصد دارید کدی
بنویسید که هم روی ویندوز و هم روی سیستم‌عامل‌های واقعی بتونه از شبکه استفاده
کنه
حتماً ادامهٔ مطلب رو بخونید.</p>

<!--more-->


<p>در لینوکس API ساده و بسیار کاربردی برای برنامه‌نویسی شبکه وجود داره که تقریباً
تمام این API استاندارد شده. توابع زبان سی که خیلی ساده کارهایی رو با فلسفهٔ
یونیکس (≈ هرچیزی یک فایل هست برای نوشتن و خواندن) انجام میده. به راحتی و با
استفاده از این API سطح پایین میشه برنامه‌های شبکه با کارایی بالا نوشت.</p>

<p>مشکل از جایی شروع میشه که این برنامه‌ها بخوان سمت ویندوز برن. متأسفانه
سیستم‌عامل ویندوز از نظر طراحی هیچ استاندارد خاصی رو رعایت نکرده و تنها
<a href="https://brianreiter.org/2010/08/24/the-sad-history-of-the-microsoft-posix%20-subsystem/">قسمت‌هایی از مشخصات POSIX</a>
رو به‌صورت دست و پا شکسته و ناقص پیاده‌سازی کرده. از
طرف دیگه API خوبی هم  برای کار کردن با سوکت‌ها نداره. نصف توابعی که فراهم شده
POSIX
هستند و نصف دیگه کاملاً
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms741394%%2028v=vs.85%29.aspx">من‌درآوردی</a>.</p>

<p>معمولاً برنامه‌های بزرگ برای حل این مشکلات از کتابخانه‌هایی که پیاده‌‌سازی‌های
چندسکویی (cross-platform) فراهم کردند استفاده می‌کنند. معروف‌ترین این
پیاده‌سازی‌ها
<a href="https://pocoproject.org">poco</a>,
<a href="www.cs.wustl.edu/~schmidt/ACE.html">ACE</a>,
<a href="https://think-async.com/">asio</a> و
<a href="http://zeromq.org/">ØMQ</a>
هستند. مشکلی که استفاده از این کتابخانه‌ها داره اینه که:</p>

<ul>
<li>خیلی پیچیده و بزرگ هستند. (بعضی‌ها حتا چندین مگابایت پیش‌نیازی اضافه
می‌کنند. مثل کیوت)</li>
<li>برای کارهای خاص و الگوهای پیچیده ساخته شده‌اند. (مثلا asio برای
معماری‌های async و ZMQ برای الگوهای ارتباطی خاص)</li>
</ul>


<p> به همین دلیل جای خالی یک کتابخانهٔ <strong>ساده</strong> و <strong>بسیار سبک</strong> که با کمترین
هزینه؛ برای ویندوز و لینوکس رابط برنامه‌نویسی <strong>سطح سوکت</strong> فراهم کنه احساس
می‌شد. متأسفانه من همچین کدی پیدا نکردم. و شروع کردم به نوشتن یک کتابخانهٔ آزاد
و خیلی خیلی ساده به زبان سی که امکان برنامه‌نویسی شبکه در سطح سوکت رو برای هر
دو سیستم‌عامل فراهم می‌کنه. نتیجه چیزی شد که خودم خیلی ازش راضی بودم و تصمیم
گرفتم منتشرش کنم.</p>

<p>این کتابخانه از اینجا قابل دسترسی هست: <a href="https://github.com/soroush/libcpnet">https://github.com/soroush/libcpnet</a></p>

<h2>ویژگی‌ها</h2>

<ul>
<li>API سطح سوکت هست. هیچ پیش‌فرضی در مورد الگوی برنامه‌نویسی یا پروتکل‌های سطح بالاتر از انتقال گرفته نشده؛</li>
<li>سوکت‌های UDP و TCP تقریباً به‌طور کامل پشتیبانی میشن؛</li>
<li>کد استاندارد سی هست (درواقع C99) که البته با C11 هم کامپایل میشه؛</li>
<li>کد روی سیزده پلتفرم مختلف تست شده. (ویژوال استودیو ۲۰۱۷ و ۲۰۱۵ &ndash; release و debug &ndash; استاتیک و داینامیک + نسخه‌های 4.7 4.8 4.9 5.4 و 6 از gcc)؛</li>
</ul>


<h2>محدودیت‌ها</h2>

<ul>
<li>در حال حاضر فقط سوکت‌های datagram و stream (در واقع UDP و TCP) رو پیاده‌سازی
کردم. این‌ها پرکاربردتر از بقیهٔ انواع سوکت‌ها هستند. البته سوکت‌های انواع دیگه رو هم به
مرور اضافه می‌کنم؛</li>
<li>این API کامل نیست. یعنی تمام توابع رو (مخصوصاً توابعی رو که هم توی لینوکس و
هم توی ویندوز یکسان هستند) پوشش نمیده. دلیلش واضحه: دلیلی ندیدم پیاده‌سازی کنم.</li>
</ul>


<p>با وجود این محدودیت‌ها کتابخانه کاملاً کاربردی و قابل استفاده هست و مشکلات زیادی رو حل می‌کنه.</p>

<h2>کد</h2>

<p>هیچ چیز بهتر از کد نمی‌تونه توضیح بده (: کد سمت کلاینت برای اتصال از نوع TCP یه
همچین چیزی میشه:
```c
/<em> Client-side sample code </em>/
/<em> Initialize networking API (Only needed in Windows) </em>/
net_init();
/<em> Start a client </em>/
socket_t socket = net_socket(SOCK_STREAM);
/<em> Connect to port 50001 </em>/
if(net_connect(socket, &ldquo;127.0.0.1&rdquo;, 50001) != 0)
{</p>

<pre><code>fprintf(stderr, "Unable to connect: %s", net_last_error();
exit(-1);
</code></pre>

<p>}
char buffer[1024];
/<em> Write to socket </em>/
ssizet io_size = net_write(socket, buffer, 1024);
if(io_size &lt; 0)
{</p>

<pre><code>fprintf(stderr, "Unable to write: %s", net_last_error();
exit(-1);
</code></pre>

<p>}
io_size = net_read(socket, buffer, 1024);
if(read_size &lt;= 0) {</p>

<pre><code>fprintf(stderr, "Unable to read: %s", net_last_error();
exit(-1);
</code></pre>

<p>}
/<em> &hellip; </em>/
/<em> Cleanup (Only needed in Windows) </em>/
net_clean();
```</p>

<p>و کد سمت سرور برای باز کردن یک پورت و جواب دادن به اتصالات مختلف:
```c
/<em> Initialize networking API (if any needed) </em>/
net_init();
/<em> Start a server </em>/
socket_t socket = net_socket(SOCK_STREAM);
/<em> Bind on port 50001 </em>/
uint16_t port = 50001;
if(net_bind(socket, NULL, &amp;port) != 0) {</p>

<pre><code>fprintf(stderr, "Unable to bind: %s", net_last_error());
exit(-1);
</code></pre>

<p>}
/<em> Listen for incomming connections (backlog=10) </em>/
net_listen(socket, 10);
/<em> Accept clients </em>/
char address[46];
socket_t client = net_accept(socket, address, &amp;port);
fprintf(stderr, &ldquo;Client connected. Remote Address:`%s' Assigned port number: %d\n&rdquo;, address, port);
char buffer[1024];
ssize_t r = net_read(client, buffer, 1024);
if(r &lt; 0) {</p>

<pre><code>fprintf(stderr, "Unable to read from socket: ", net_last_error());
exit(-1);
</code></pre>

<p>}
if(r == 0) {</p>

<pre><code>printf("Remote client stopped.");
net_close(client);
exit(-1);
</code></pre>

<p>}
ssize_t w = net_write(client, buffer, r);
if(w &lt;= 0) {</p>

<pre><code>fprintf(stderr, "Unable to write to socket: ", net_last_error());
exit(-1);
</code></pre>

<p>}
```</p>

<p>چند تا نکته:</p>

<ul>
<li>همهٔ توابع با ‪<code>net_</code>‬ شروع میشن.</li>
<li>روی لینوکس لازم نیست ‪<code>net_init()</code>‬ و ‪<code>net_clean()</code>‬ رو بنویسید، اما ضرری هم نداره (هیچ کاری نمی‌کنه)</li>
</ul>

]]></content>
  </entry>
  
</feed>

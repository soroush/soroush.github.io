<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[طبقه‌بندی‌هاqt,c++,calendar | اختاپوس خسته]]></title>
  <link href="http://soroush.github.io/categories/qt-c-plus-plus-calendar/atom.xml" rel="self"/>
  <link href="http://soroush.github.io/"/>
  <updated>2017-09-16T00:20:07+04:30</updated>
  <id>http://soroush.github.io/</id>
  <author>
    <name><![CDATA[سروش]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[تقویم هجری شمسی در کیوت]]></title>
    <link href="http://soroush.github.io/blog/calendaring-in-qt/"/>
    <updated>2017-07-27T00:00:00+04:30</updated>
    <id>http://soroush.github.io/blog/calendaring-in-qt</id>
    <content type="html"><![CDATA[<p>همیشه جای خالی تقویم هجری شمسی در کیوت برای من آزاردهنده بوده. وقتی می‌خواستم تاریخ رو نشون بدم یا باید
از ویجت‌هایی که خودم ساختم استفاده می‌کردم یا به تاریخ گرگورین (میلادی) بسنده می‌کردم. از نسخهٔ 4.6 و دقیقاً بعد از زمانی که
ترجمهٔ فارسی کیوت رو منتشر کردم، به فکر پیاده‌سازی تقویم رسمی کشور توی این فریم‌ورک بودم. متأسفانه اون روزها امکان پیاده‌سازی وجود نداشت.
بالأخره بعد از گذشت ۶ سال و فراموش شدن موضوع تونستم تقویم جلالیِ هجری شمسی رو برای کیوت 5.10 پیاده‌سازی کنم. نمی‌خوام از الان
امیدوارتون کنم اما شانس بسیار خوبی وجود داره که با نسخهٔ 5.10 (یعنی حوالی آبان ماه امسال) این تقویم منتشر بشه (: این پست به چالش‌ها
و روال توسعهٔ تقویم و نحوهٔ استفاده از API اختصاص داده شده.
<img class="center" src="/images/posts/qt5-calendars/jalali.gif" title="نمونهٔ اجرا" ></p>

<!--more-->


<h2>مشکل سازگاری عقبگرد</h2>

<p>فرصتی که با تغییر نسخه از چهار به پنج به وجود آمده بود هم از دست رفت. و در آخر باید برای پیاده‌سازی تقویم منتظر نسخهٔ ۶ کیوت می‌بودیم.
ممکنه این سؤال برای شما پیش بیاد که خوب چرا؟ چرا نمی‌شد مثلاً توی نسخه‌های وسطی پیاده‌سازی رو انجام داد؟
خوب چون باید Source Compability و  Backward Compability رعایت می‌شدند.
یعنی مثلا وقتی کسی برنامه‌ای رو نوشته که به کیوت نسخهٔ 5.1 لینک کرده، باید بتونه بدون کامپایل دوبارهٔ برنامه‌ش؛
صرفاً نسخهٔ کیوت سیستم رو به 5.2 ارتقا بده. و این یعنی تغییر نکردن چینش (layout) حافظه برای کلاس‌هایی مثل
QDate
و البته ویجت‌هایی مثل
QDateEdit
و
QCalendarWidget
به این ویژگی میگن Drop-in Replacement. یعنی هر نسخهٔ x.y.z از هر کتابخانه‌ای باید بدون ایجاد کرش یا خطای لینک در برنامه‌هایی
که ازش استفاده کردند قابل <strong>جایگزینی</strong> با نسخهٔ x.y+α.z+β باشه&hellip;</p>

<p>خوب من این قضیه رو فراموش کردم تا این که سال پیش سر قضیهٔ متفاوتی به فکرم رسید که احتمال داره راهی برای رسیدن به این هدف بدون
شکستن سازگاری عقبگرد و سازگاری کد وجود داشته باشه. ایدهٔ خام اولیه این بود که تقویم‌ها بدون نیاز به ورود به حافظهٔ کلاس‌های Core
در کلاس‌های مجزایی پیاده‌سازی بشوند و callbackهایی به کلاس‌های تقویم در کلاس‌های اصلی ایجاد بشه! بسیار هیجان‌انگیز و البته خام بود این ایده.
اما متأسفانه وقتی ایدهٔ اصلی رو بین توسعه‌دهنده‌های کیوت مطرح کردم به من نشون دادند که این امکان وجود نداره. با این وجود میشد طور دیگری
هم پیاده‌سازی رو انجام داد. این روش آخری روش مطلوب من نبود: من دوست داشتم API عمومی QDate تقویم رو داشته باشه. اما با این روش تقویم داخل
اشیایی از نوع تاریخ قرار نمی‌گرفت. با یه مثال توضیح میدم. من دوست داشتم این‌طوری بشه:
<code>c++
QDate d = QDate::currentDate();
d.setCalendar(Qt::Jalali);
qDebug() &lt;&lt; d.toString("ddddd d MMMM yyyy"); // Thursday 5 Mordad 1396
QLocale::setDefault("fa_IR");
qDebug() &lt;&lt; d.toString("ddddd d MMMM yyyy"); // پنجشنبه ۵ مرداد ۱۳۹۶
</code>
ولی در آخر این API استفاده شد:
<code>c++
QDate d = QDate::currentDate();
qDebug() &lt;&lt; d.toString("ddddd d MMMM yyyy"); // Thursday 27 July 2017
qDebug() &lt;&lt; d.toString("ddddd d MMMM yyyy", QJalaiCalendar()); // Thursday 5 Mordad 1396
QLocale::setDefault("fa_IR");
qDebug() &lt;&lt; d.toString("ddddd d MMMM yyyy", QJalaiCalendar()); // پنجشنبه ۵ مرداد ۱۳۹۶
</code>
ناگفته نماند ایرادات زیادی توی طراحی QDate وجود داره. برای نسخهٔ 6 کیوت برنامه‌هایی دارم در مورد این که کل کلاس‌های مربوط به
تاریخ و زمان رو اصلاح کنم. (بخش بعدی بیشتر توضیح میدم که چرا ایراد داره).</p>

<h2>تقویم‌نگاری و روز ژولین</h2>

<p>تاریخ در کیوت به‌صورت تعداد روزهای گذشته از مبدأای خاص نگه داشته میشه. فقط این عدد واقعاً ذخیره میشه و برای محاسباتی مثل مقایسه و غیره
استفاده میشه. هر وقت نیاز شد این عدد به سال و ماه و روز تبدیل میشه. عدد مربوطه
<a href="https://fa.wikipedia.org/wiki/%D8%B1%D9%88%D8%B2_%DA%98%D9%88%D9%84%DB%8C%D9%88%D8%B3%DB%8C">روز ژولیوسی</a>
یا روز ژولین
( <a href="https://en.wikipedia.org/wiki/Julian_day">Julian Day</a> )
انتخاب شده که برابر با تعداد روزهای گذشته از اول ژانویهٔ ۴۷۱۳ قبل از میلاد مسیح (تقریباً ۶۷۳۰ سال پیش) تا تاریخ مورد نظر هست.
برای مثال: امروز پنجم مردادماه ۱۳۹۶ برابر با ۲۷ام جولای ۲۰۱۷ در واقع ۲٬۴۵۷٬۹۶۱ امین روز ژولیوسی هست.</p>

<p>مشکلی که این روش داره اینه که هر وقت نیاز باشه ما سال ماه یا روز رو بدونیم باید تبدیل انجام بدیم! هیچ بهینه‌سازی یا مکانیزمی برای کش کردن این تبدیل پیش‌بینی نشده و همواره وقت
ارزشمند پردازنده‌ها برای محاسبهٔ بین عدد روز ژولیوسی (JDN) و تاریخ (y,m,d) هدر میره! خوب چرا اعداد سال و ماه و روز رو به‌صورت جدا نگه نداشتن؟ به نظر من هیچ توجیهی نداره و اشتباهه.</p>

<p> تاریخ در فریم‌ورک کیوت تا قبل از مبدأ و بعد از بزرگ‌ترین عدد ممکن در پلتفرم مورد اجرا رو نمی‌تونه نشون بده. عددی که کیوت نگه می‌داره یک عدد علامت‌دار
 شصت و چهار بیتی هست. چرا علامت‌دار؟ دلیلی نداره. چرا شصت و چهار بیت؟ بازم دلیلی نداره. در واقع با ۳۲ بیت بدون علامت می‌شد دامنهٔ بسیار بزرگی از تاریخ‌ها
 رو برای محاسبات علمی ساده و کاربردهای روزمره پوشش داد. برای مثال توی پلتفرم من
(<a href="https://en.wikipedia.org/wiki/X86-64">X86_64</a>)
آخرین آخرین روز ژولیوسی پشتیبانی شده برابر است با:</p>

<p>$$2^{64-1} = 9,223,372,036,854,775,808$$</p>

<p>طبق الگوریتم تبدیل اگر این عدد رو به تاریخ گرگورین تبدیل کنیم، می‌رسیم به تاریخ $$25,252,734,927,761,842$$ که بزرگ‌ترین سال میلادی پیشتیبانی شده هست!
از شش‌هزار سال پیش تا بیست و پنج کوادریلیون سال بعد رو میشه توی QDate نگهداری کرد! واضحه که محدودهٔ محاسبهٔ سال‌ها کاملاً غیرقابل قبول هست و باید اصلاح بشه.
این یک اشتباه بزرگ در طراحی کلاس QDate هست که به نزدیک بیست سال پیش برمی‌گرده و کسی بهش اهمیتی نداده.</p>

<h3>تبدیل روز ژولیوسی به تاریخ هجری شمسی</h3>

<p>هیچ الگوریتم شناخته شده‌ای برای تبدیل تاریخ هجری شمسی وجود نداره. تقریباً تمام تقویم‌پژوهان معاصر در مورد دوره‌های کبیسه‌گری و طول سال تحقیق کرده‌‌اند که البته هیچ اشاره‌ای به
مبدأ تاریخ به شکل روز ژولیوسی و نحوهٔ تبدیل‌ها نداشتند. بنابراین من مجبور شدم روز شروع دورهٔ معاصر (یکم فروردین سال ۴۷۵ هجری شمسی) رو محاسبه کنم و با استفاده از  طول سال
میانگین که در مطالعات موسی اکرمی با دقت بسیار خوبی محاسبه شده، یک الگوریتم نه چندان بهینه برای تبدیل تاریخ به روز ژولیوسی و برعکس درست کنم.</p>

<p>این الگوریتم اما چالش‌های زیادی داشت. از جمله این که سال‌های منفی و دوره‌های قبل از دورهٔ فعلی مشکل ایجاد می‌کردند. توضیح این که سال صفر در تقویم‌نگاری جلالی وجود نداره
قبل از سال یک مستقیم میریم سال منفیِ یک. همین قضیه برای تقویم اسلامی و گرگورین هم صادق هست. به‌رحال الگوریتم به خوبی جواب داد و جز برای یکی دو سال کبیسه که با
الگوریتم ۳۳ ساله متفاوت بود، مشکل خاصی نداره. در مورد تفاوت‌ها من تصمیم گرفتم که الگوریتم مبتنی‌بر دوره‌های ۲۰۲۸ ساله با کبیسه‌های محاسبه شده توسط اکرمی رو ملاک
قرار بدم. چون الگوریتم ۳۳ ساله ضعیف‌تر ساخته شده و سال کبیسه رو درست حساب نمی‌کنه. هرچند تقویم رسمی کشور براساس هیچکدام از این دو تا نیست! تقویم رسمی هیچ نظری
در مورد سال‌های کبسهٔ جدید و کبیسه بودن یا نبودن سال‌های قدیم نداره. در مورد سال‌های جدید هر سال براساس مشاهدات اعتدال بهاری تصمیم گرفته میشه که سال کبیسه هست یا نه.
البته این مشاهدات در زمان معاصر باعث میشه که الگوریتم من تطابق صددرصدی با سال‌های بعدی و سال‌های بعد از ۱۳۰۲ داشته باشه که به نظرم کافی هست.</p>

<p>یک مشکل بزرگی که این الگوریتم داره اینه که دقیق تست نشده! هیچ مرجع قابل اطمینانی که داده‌های تقویمی در اختیار عموم قرار داده باشه پیدا نکردم. حداقل هیچ مرجعی هم وجود نداره که
تاریخ‌های معادل گرگورین و جلالی رو داشته باشه! تنها مرجعی که وجود داره و میشه ازش برای تست استفاده کرد الگوریتم تبدیل تاریخ ۳۳ ساله  است که توسط تیم فارسی‌وب شریف
توسعه داده شده. این هم البته دقیق نیست و برای سال‌های منفی اصلا کار نمی‌کنه و برای سال‌های پیش از شروع دوره (سال یک تا ۴۷۵) مشکل داره.</p>

<h2>بومی‌سازی</h2>

<p>کیوت از بومی‌سازی (Localisation &ndash; l18n) استفاده می‌کنه. این یکی از بهترین ویژگی‌های این فریم‌ورک بسیار باحال هست (: هرچند تقریباً هیچ توسعه‌دهندهٔ فارسی‌زبانی از Locale استفاده نمی‌کنه
(در حالی که ما بیشتر از همه بهش احتیاج داریم&hellip;). برای اضافه کردن یک تقویم جدید نیاز بود داده‌های بومی‌سازی برای تمام زبان‌های دنیا تولید بشه. برای مثال کیوت نیاز داشت که بدونه اسم
ماه دوم تقویم هجری شمسی در زبان انگلیسی «<strong>Ordibehesht</strong>» در عربی «<strong>أذربیهشت</strong>» و در کره‌ای «<strong>오르디베헤쉬트</strong>» هست.</p>

<p>اسکریپت‌هایی برای کیوت نوشته شده بودند که داده‌های
<a href="http://cldr.unicode.org/">CLDR</a>
رو اول تبدیل به یک فایل بسیار بزرگ XML و بعد تبدیل به کد C++ می‌کردند. این‌ها مشخصاً ناکافی بودند و من باید الگوریتم‌های موجود در این اسکریپت‌ها رو طوری تغییر میدادم که برای داده‌های
تقویم فارسی هم یک بافر بزرگ تشکیل بدند و این بافر رو توی کد C++ اضافه کنند.</p>

<h2>کلاس‌های گرافیکی</h2>

<p>کار کردن با تاریخ و زمان بدون درنظر گرفتن ویجت‌های گرافیکی خیلی جالب به نظر نمی‌رسه. بنابراین من باید حداقل سه تا کلاس</p>
]]></content>
  </entry>
  
</feed>
